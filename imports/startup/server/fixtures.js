// Fill the DB with example data on startup

import { Meteor } from 'meteor/meteor';
import { Roles } from 'meteor/alanning:roles';
import { Accounts } from 'meteor/accounts-base';
import { JsonRoutes } from 'meteor/simple:json-routes';
import { categories } from '../../../stores/categories.js';
import { teamCategories } from '../../../stores/teamCategories.js';
import { checkpoints } from '../../../stores/checkpoints.js';
import RoleTypes from '../../api/users/roles/roleTypes.js';
import { Checkpoints } from '../../api/checkpoints/checkpoints.js';
import { countries } from '../../../stores/countries';
import { Countries } from '../../api/countries/countries';
import { Identifiers } from '../../api/identifiers/identifiers';
import { Races } from '../../api/races/races.js';
import { Categories } from '../../api/categories/categories';
import { TeamCategories } from '../../api/teamCategories/teamCategories';
import { CompetitionFeatures } from '../../api/competitionFeatures/competitionFeatures';
import { Federations } from '../../api/federations/federations';
import { federations } from '../../../stores/federations';
import { Clubs } from '../../api/clubs/clubs';
import { Disciplines } from '../../api/disciplines/disciplines';
import { clubsEsp } from '../../../stores/external/clubs_esp.js';
import { competitionFeatures } from '../../../stores/competitionFeatures';
import { competitionsEAA2018 } from '../../../stores/external/competitionsEAA2018';
import { athletesIAAF } from '../../../stores/external/athletesIAAF';
import { disciplinesIAAF } from '../../../stores/disciplinesIAAF';
import MqttManager from './mqtt.js';
//import { createTestingUsers } from './populateDb';
import './accounts.js';
import Common from '../../../both/lib/common.js';
import { Competitors } from '../../api/competitors/competitors.js';
import { ResultEntries } from '../../api/resultEntries/resultEntries.js';


function fixAutogeneratedEpcs() {
  console.log('Fixing Bibs and EPCs...');
  const ids = Identifiers.find().fetch();
  ids.forEach(function(id) {
    const epc = Common.epcToHex(id.bib);
    Identifiers.update({ _id: id._id }, { $set: { epcs: [epc] } });
  });
  // Now the competitors' epcs
  const competitors = Competitors.find().fetch();
  competitors.forEach(function(competitor) {
    const epc = Common.epcToHex(competitor.bib);
    Competitors.update({ _id: competitor._id }, { $set: { epcs: [epc] } });
  });
}

Meteor.startup(() => {
  // Sets the environment variable with the SMTP data
  //process.env.MAIL_URL = 'smtp://2d3f5be0e8d9dba98412fd3c24c73a5d:468420017d6a3fcfa39db2c74fbd8a36@in-v3.mailjet.com:587';
  //process.env.MAIL_URL = 'smtp://127.0.0.1:25';

  //const MQTT_SERVER = 'mqtt://espinr.ddns.net';
  //const MQTT_SERVER = 'mqtt://192.168.0.154';
  //const MQTT_SERVER = 'mqtt://localhost';

  // Enable cross origin requests for all endpoints
  JsonRoutes.setResponseHeaders({
    'Cache-Control': 'no-store',
    Pragma: 'no-cache',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, OPTIONS', //'GET, PUT, POST, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
  });

  const MQTT_SERVER = Meteor.settings.mqtt_broker;
  const MQTT_PORT = Meteor.settings.mqtt_port;

  // create the roles if they don't already exist
  if (!Meteor.roles.findOne({ name: RoleTypes.ADMIN })) {
    Roles.createRole(RoleTypes.ADMIN);
  }
  if (!Meteor.roles.findOne({ name: RoleTypes.PUBLIC })) {
    Roles.createRole(RoleTypes.PUBLIC);
  }
  // Create an admin/admin account if it doesn't exist
  if (Meteor.users.find({ username: 'admin' }).count() < 1) {
    const userId = Accounts.createUser({
      username: 'admin',
      email: 'martin@espinr.es',
      profile: {
        name: 'admin',
        firstName: 'admin',
        passport: '00000000',
        lastName: 'admin',
        birthDate: new Date(),
        gender: 'Male',
        phone: '000000000',
        acceptPolicy: true,
      },
      createdAt: new Date(),
      password: '4dm1n4dm1n',
    });
    if (userId) {
      Roles.addUsersToRoles(userId, [RoleTypes.ADMIN, RoleTypes.PUBLIC]);
    }
  }
  // User by default when a competitor needs to be created
  if (Meteor.users.find({ username: '_bydefault_' }).count() < 1) {
    const userId = Accounts.createUser({
      username: '_bydefault_',
      email: 'athlete@espinr.es',
      profile: {
        name: '####UNKNOWN####',
        firstName: 'Athlete',
        birthDate: new Date(),
        gender: 'Female',
        passport: '000000000',
        lastName: 'Unknown',
        phone: '000000000',
        acceptPolicy: true,
      },
      createdAt: new Date(),
      password: '_bydefault_',
    });
    if (userId) {
      Roles.addUsersToRoles(userId, [RoleTypes.PUBLIC]);
    }
  }

  // Race by default for new competitors on the fly
  if (Races.find({ identifier: '_bydefault_' }).count() < 1) {
    const idRace = Races.insert({
      name: 'Race by default',
      startDate: new Date(),
      maxCompetitors: 10000,
      createdAt: new Date(),
      resultLists: [],
      checkpoints: [],
    });
    Races.update({ _id: idRace }, { $set: { identifier: '_bydefault_' } });
  }
  // Load for the first time the categories
  if (Categories.find({ identifier: categories[0].identifier }).count() < 1) {
    for (let i = 0; i < categories.length; i += 1) {
      Categories.insert(categories[i]);
    }
  }
  // Loads the category by default:
  if (Categories.find({ identifier: 'OVERALL' }).count() === 0) {
    Categories.insert({
      identifier: 'OVERALL',
      name: 'General',
      description: 'CategorÃ­a general',
      global: true,
    });
  }
  Categories.update({ identifier: 'OVERALL' }, { $set: { name: 'General' } });
  // Load for the first time the categories for teams
  if (TeamCategories.find({ identifier: teamCategories[0].identifier }).count() < 1) {
    for (let i = 0; i < teamCategories.length; i += 1) {
      TeamCategories.insert(teamCategories[i]);
    }
  }
  // Loads the teams category by default:
  if (TeamCategories.find({ identifier: 'OVERALL' }).count() === 0) {
    TeamCategories.insert({
      identifier: 'OVERALL',
      name: 'Todos los equipos',
      description: 'Todos los equipos',
    });
  }

  // Load for the first time the checkpoints
  if (Checkpoints.find({}).count() < 1) {
    for (let i = 0; i < checkpoints.length; i += 1) {
      Checkpoints.insert(checkpoints[i]);
    }
  }
  // Load for the first time the countries
  if (Countries.find({}).count() < 1) {
    for (let i = 0; i < countries.length; i += 1) {
      Countries.insert(countries[i]);
    }
  }

  // Load the list of federations
  if (Federations.find({}).count() < 1) {
    for (let i = 0; i < federations.length; i += 1) {
      Federations.insert(federations[i]);
    }
  }

  // Load for the first time the competition features
  if (CompetitionFeatures.find({}).count() < 1) {
    for (let i = 0; i < competitionFeatures.length; i += 1) {
      CompetitionFeatures.insert(competitionFeatures[i]);
    }
  }

  // Load for the first time the IAAF disciplines
  if (Disciplines.find({ identifier: disciplinesIAAF[0].identifier }).count() < 1) {
    for (let i = 0; i < disciplinesIAAF.length; i += 1) {
      Disciplines.insert(disciplinesIAAF[i]);
    }
  }

  // Load the list of clubs of spain
  if (Clubs.find({ alternate: 'UNATTACHED' }).count() === 0) {
    Clubs.insert({ alternate: 'UNATTACHED', name: 'UNATTACHED' });
    for (let i = 0; i < clubsEsp.length; i += 1) {
      const idClub = Clubs.insert(clubsEsp[i]);
      // Adds the country to the club
      const spain = Countries.findOne({ 'codes.iso': 'ESP' });
      Clubs.update(idClub, {
        $set: {
          countryId: spain._id,
          'location.address.addressCountry': spain.codes.iso,
        },
      });
    }
  }

  //fixAutogeneratedEpcs();
  //Meteor.call('identifiers.createBatchFromTo', 'CstZLCEYhRgnPvzwr', 101, 500);
/*
  console.log('Fixing times');
  const competitors = Competitors.find({ idRace: '2K54eYGLoqwzNWCmx' }).fetch();
  competitors.forEach(function(competitor) {
    const entries = ResultEntries.find({competitorId: competitor._id }).fetch();
    entries.forEach(function(entry) {
      if (entry.splits && entry.splits.length > 0) {
        const newSplits = entry.splits;
        newSplits[0].performance = entry.splits[0].performance - 180;
        ResultEntries.update({ _id: entry._id }, { $set : { splits: newSplits }});
      }
    });    
  });*/

  // Load the 2018 calendar of EAA
  if (Races.find({ name: competitionsEAA2018[0].name, description: competitionsEAA2018[0].description }).count() === 0) {
    for (let i = 0; i < competitionsEAA2018.length; i += 1) {
      // Changes the country code for the real country
      const iocCode = competitionsEAA2018[i].location.address.addressCountry;
      const country = Countries.findOne({ 'codes.ioc': iocCode });
      const competition = competitionsEAA2018[i];
      if (country) {
        competition.countryId = country._id;
        competition.location.address.addressCountry = country.codes.iso;
      }
      const idRace = Races.insert(competition);
      // As they may not be races, 
      Meteor.call('race.geocode', idRace);
    }
  }
  // IAAF athletes
  if (Meteor.users.find({ username: athletesIAAF[0].username }).count() === 0) {
    for (let i = 0; i < athletesIAAF.length; i += 1) {
      const athlete = athletesIAAF[i];
      const country = Countries.findOne({ 'codes.ioc': athlete.country });
      delete athlete.country;
      if (country) {
        athlete.profile.countryId = country._id;
      }
      athlete.birthDate = new Date(athlete.birthDate);
      try {
        Meteor.users.insert(athlete);
      } catch (ex) {
      }
    }
  }

  // Subscribe to all topics
  const mqttManager = new MqttManager(MQTT_SERVER, MQTT_PORT);
  mqttManager.runSubscriptions();
});
